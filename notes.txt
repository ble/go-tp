Structure of the client-side:

Client-Passive
Model
Client-Active
UI

Active client:
  gets initial game state
  makes user-initiated requests

Passive client:
  polls / listens on websocket for game state updates and mutates the model

Active client interface:
  GetGameState()
  GetStack()
  GetDrawing()
  AppendToDrawing()
  PassStack()
  Chat()

ALL OF THESE RETURN `goog.result.Result`s (which are Futures or Promises for
those of you playing along at home.)


The active client and model parts of this design have been basically achieved;
that means it's time to get the passive client right.

How should this connect with the existing comet loop code, if at all?

What is the existing comet loop code?
Part 1: a basic comet loop, emitting only
  START
  STOP
  and DATA events
Part 2: an extension of that basic comet loop, adding a `lastTime` url param

While there are bits that I may not completely remember here, it seems solid
and perhaps more importantly still a good fit for what I had in mind re making
sure that clients do not desync too badly.

IMPORTANT PIECE OF GLUE HERE:
  between the comet time loop and the model lies something that has to make
  calls to the game updating interface.

Now it's time to start roughing in the UI (in the roughest fashion possible)
It's super nice that the actual client interaction is entirely available by
literally typing `client.passStack`, `client.startGame`, etc

Ah, yes, it's time for another chunk of glue: the code that will load the
actual contents of a stack

or `game.myPlayer().stacksHeld()[0].id()`
or even
`
game.myPlayer().stacksHeld()[0].fetchState();
var drawingId = game.myPlayer().stacksHeld()[0].drawings()[0].id();
client.appendToDrawing(drawingId, {'trouble':'incoming'});
`

TODO: server-side, no way to complete drawing at present
