okay, now I've got some pretty decent stuff going on

the current glue code is not so well organized, though

first of all, it's living in the HTML page itself
second of all, its structure has not been carefully thought out
third, there's something more than a little inconvenient about present data
access with long-ass stuff like
`game.myPlayer().stacksHeld()[0].id()`
game.myPlayer().stacksHeld()[0].fetchState();
var drawingId = game.myPlayer().stacksHeld()[0].drawings()[0].id();
client.appendToDrawing(drawingId, {'trouble':'incoming'});
`
but it's not clear that's a real liability


What code lives there right now?

convenient namespacing
initializing `client` with correct URL
initializing `game` with client
starting `comet`
sends a test chat
listens for game events (??!never triggered??!)
  -->never triggered because we're passing an array of event types to
     `game.listen` which apparently doesn't understand that...

definition of PassiveHandler

client.chat("What's up in this piece?");

var handler = new PassiveHandler(game);
comet.listen(ble.net.EventType.COMET_DATA, handler);

game.listen([_.EventType.JOIN, _.EventType.PASS, _.EventType.START], function(event) {
  console.log("A GAME EVENT OCCURRED:");
  console.log(event);
});

var fetchRequest = game.fetchState();
fetchRequest.wait(function(result) {
  if(result.getError() !== undefined) {
    console.error(result.getError());
    return;
  }
  var value = result.getValue();
  var time = value['lastTime'];
  if(time === undefined) {
    console.error('didn\'t get a time');
    return
  }

  console.log(value);
  comet.runAt(time);
});

//test some basic functionality...

//check if we're holding a stack, asynchronously update its contents
var withStartedGame = function() {
  var me = game.myPlayer();  
  var myStacks = me.stacksHeld();
  if(myStacks.length < 1)
    return;
  var topStack = myStacks[0];
  var request = topStack.fetchState();
  request.wait(goog.bind(withLoadedStack, this, topStack));
};

//get the top drawing of the stack, asynchronously fetch its contents
var withLoadedStack = function(topStack) {
  var topDrawing = topStack.drawings()[0];
  var request = topDrawing.fetchState();
  request.wait(goog.bind(withLoadedDrawing, this, topDrawing));
};

//just show that we got the drawing
var withLoadedDrawing = function(topDrawing) {
  console.log(topDrawing.player());
  console.log(topDrawing.content());
};


//When we're done getting the initial game state...
fetchRequest.wait(function(result) {
  if(result.getError() !== undefined) {
    return;
  }

  //start the game if need be and wait for stacks to be passed...
  if(!game.isStarted()) {
    var request = client.startGame();
    goog.events.listen(game, _.EventType.PASS, withStartedGame);
  } else {
  //if the game's already started, we should already have stacks
    withStartedGame();
  }
});




