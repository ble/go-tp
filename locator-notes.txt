One idea is to have objects that can give you their own URL; they can provide
their own Locator / they can tell you where to find themselves.

Another idea is to have an object (really, just a function) that maps from
objects to the URL at which to find them.  This is more appealing, in my mind.

Why is it more appealing?

1) Providing a URL for Monsieur J. Random Object: might be the good Monsieur's
job but it would probably be better provided by some other service.  

2) Symmetry: this is something like the dual of a router:

URL of HTTP request        ==(router)---> Function used to process request
Object accessible via http --(locator)==> URL used to access object

Or, with arrows flopping:
URL of HTTP request        ===(router)---> Function used to process request
URL used to access object  <==(locator)--- Object accessible via http 

Router and locator in some cases need each other; yea, need each other as
badly as peanut butter and chocolate do.

Structuring the code in router/locator idiom could even be used to define
both directions of the mapping in a single location; exploiting the duality
beats the shit out of the ad-hoc alternative.

Definition in a single location suggests the possibility of having an
inter-linked set of resources but being able to refactor as many URLs as one
cares to at one fell swoop!

More conservatively, even if the single location definition is ugly or not
possible, having a router and a locator means that you can do an important
debug check: testing to see if a URL to a resource in your application that
you are about to send to your user really is (or at least matches the pattern
of) a URL that actually corresponds to a thing.

With a specialized-enough implementation of router and locator, you could
verify that the URL that you get for a thing will in fact come back to some
handler that uses that exact same thing. <-- not sure if this is actually a
good idea; depends on elegance / overhead.

Hokay, explicit duality solves that problem.  Next problem.

THE NEXT PROBLEM IIIISSSSS:
Ensuring Consistent Concurrent Access

Well this one is disappointingly straightforward, at least for this
application; some objects are still in the process of being altered and
others are not; all objects being altered except for games and users are being
altered in the context of a game and are independent of all objects outside of
that game.

The trivial way to make this work is to identify whether a request to read or
alter an object refers to an object in-progress and if it does, to issue a
request to some struct-plus-goroutine doohickey that accepts concurrent
requests to do thangs and serializes them in executing them. *whaps hands
together as if cleaning flour off of them*

In practice, this means that my handler for drawings will need to figure out
if the drawing is complete or not to decide whether to ask for the drawing
through its associated game... tolerable, I guess.  We'll give it a shot and
see how it goes.

In another thought... what is the concurrent-access struct-plus-goroutine
doohickey?  Is that something that would be worth thinking of as the "room" in
which the game unfolds?
